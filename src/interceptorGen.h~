#include "pin.H"
//Declaration of Pin Interceptors.
#if defined(TARGET_MAC)
#define EXP "_exp"
#define SQRT "_sqrt"
#define SIN "_sin"
#define COS "_cos"
#define TAN "_tan"
#define ASIN "_asin"
#define ACOS "_acos"
#define ATAN "_atan"
#else
#define EXP "exp"
#define SQRT "sqrt"
#define SIN "sin"
#define COS "cos"
#define TAN "tan"
#define ASIN "asin"
#define ACOS "acos"
#define ATAN "atan"
#endif


int skip = 1; 
int expCntr = 0; 
int sqrtCntr = 0; 
int sinCntr = 0; 
int cosCntr = 0; 
int tanCntr = 0; 
int asinCntr = 0; 
int acosCntr = 0; 
int atanCntr = 0; 
std::vector<int> callCntr = {0,0,0,0,0,0,0,0}; 
std::string Backtrace(int skip); 
std::string rtnStack;


/* ========================================================================= */
/* Commandline Switches                                                      */
/* ========================================================================= */
KNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool","o", "dataTree.txt",
 "specify trace file name");


/* ========================================================================= */
/* Analysis routines                                                         */
/* ========================================================================= */
VOID Arg1Before(CHAR* name, double a)//CHAR * name, ADDRINT size)
{
	int rtnID; 
	std::string str(name); 
	if (str == "exp") rtnID = 0; //2869; 
	if (str == "sqrt") rtnID = 1; //2889; 
	if (str == "sin") rtnID = 2; //2858; 
	if (str == "cos") rtnID = 3; //2857; 
	if (str == "tan") rtnID = 4; //2860; 
	if (str == "asin") rtnID = 5; //2864; 
	if (str == "acos") rtnID = 6; //2862; 
	if (str == "atan") rtnID = 7; //2837; 
	
	switch (rtnID)
	{
		case 0:
			rtnStackVector[rtnID][expCntr]=Backtrace(skip=1);
			cout << "Stack of exp: " << expCntr << " is: " << endl << rtnStackVector[rtnID][expCntr] << endl; 
			expCntr++;
			break;
		case 1: 
			rtnStackVector[rtnID][expCntr]=Backtrace(skip=1);
			cout << "Stack of sqrt: " << sqrtCntr << " is: " << endl << rtnStackVector[rtnID][expCntr] << endl; 
			sqrtCntr++;
			break;
		case 2: 
			rtnStackVector[rtnID][expCntr]=Backtrace(skip=1);
			cout << "Stack of sin: " << sinCntr << " is: " << endl << rtnStackVector[rtnID][expCntr] << endl; 
			sinCntr++;
			break;
		case 3: 
			rtnStackVector[rtnID][expCntr]=Backtrace(skip=1);
			cout << "Stack of cos: " << cosCntr << " is: " << endl << rtnStackVector[rtnID][expCntr] << endl; 
			cosCntr++;
			break;
		case 4: 
			rtnStackVector[rtnID][expCntr]=Backtrace(skip=1);
			cout << "Stack of tan: " << tanCntr << " is: " << endl << rtnStackVector[rtnID][expCntr] << endl; 
			tanCntr++;
			break;
		case 5: 
			rtnStackVector[rtnID][expCntr]=Backtrace(skip=1);
			cout << "Stack of asin: " << asinCntr << " is: " << endl << rtnStackVector[rtnID][expCntr] << endl; 
			asinCntr++; 
			break; 
		case 6:
			rtnStackVector[rtnID][expCntr]=Backtrace(skip=1);
			cout << "Stack of acos: " << acosCntr << " is: " << endl << rtnStackVector[rtnID][expCntr] << endl; 
			acosCntr++; 
			break; 
		case 7: 
			rtnStackVector[rtnID][expCntr]=Backtrace(skip=1); 
			cout << "Stack of atan: " << atanCntr << " is: " << endl << rtnStackVector[rtnID][expCntr] << endl; 
			atanCntr++; 
			break; 
	}
	//std::ostringstream oss;
	//oss << name << "RTN";
	//std::string var = oss.str();
	
	TraceFile << "Function: " << name << "	 value: " << a << endl;
	treeFill(a, rtnID, callCntr[rtnID]); 
	callCntr[rtnID]++; 
}

VOID FuncAfter(ADDRINT ret)
{
	TraceFile << "  returns " << (double*)ret << endl;
}


/* ========================================================================= */
/* Instrumentation routines                                                  */
/* ========================================================================= */
VOID Image(IMG img, VOID *v) 
{
	RTN expRtn = RTN_FindByName(img, EXP); 
	if (RTN_Valid(expRtn)) 
	{ 
		RTN_Open(expRtn); 
		
		//int PinCCTLibInit(IsInterestingInsFptr isInterestingIns, FILE* logFile, CCTLibInstrumentInsCallback userCallback, VOID* userCallbackArg, BOOL doDataCentric = false); 
		int PinCCTLibInit(IsInterestingInsFptr isInterestingIns, TraceFile , CCTLibInstrumentInsCallback userCallback, VOID* userCallbackArg, false); 
		// Instrument exp() to print the input argument value and the 
		// return value.
		RTN_InsertCall(expRtn, IPOINT_BEFORE, (AFUNPTR)Arg1Before, IARG_ADDRINT,
		               EXP,IARG_FUNCARG_ENTRYPOINT_VALUE, 0, IARG_END); 
		//print_stacktrace(); 
		
		//TraceFile << "Function: exp" << " 	 address: " << RTN_Address(expRtn) << endl; 
		TraceFile << "Function: exp" << endl<< "stack: "<< endl << Backtrace(skip=1) << endl; 
		TraceFile << "expRtn ID: " << std::dec << LEVEL_PINCLIENT::RTN_No(expRtn) << endl; 
		TraceFile << "--------------------------------------------------------------------------------" << endl; 
		RTN_Close(expRtn); 
	} 

	RTN sqrtRtn = RTN_FindByName(img, SQRT); 
	if (RTN_Valid(sqrtRtn)) 
	{ 
		RTN_Open(sqrtRtn); 
		
		//int PinCCTLibInit(IsInterestingInsFptr isInterestingIns, FILE* logFile, CCTLibInstrumentInsCallback userCallback, VOID* userCallbackArg, BOOL doDataCentric = false); 
		int PinCCTLibInit(IsInterestingInsFptr isInterestingIns, TraceFile , CCTLibInstrumentInsCallback userCallback, VOID* userCallbackArg, false); 
		// Instrument sqrt() to print the input argument value and the 
		// return value.
		RTN_InsertCall(sqrtRtn, IPOINT_BEFORE, (AFUNPTR)Arg1Before, IARG_ADDRINT,
		               SQRT,IARG_FUNCARG_ENTRYPOINT_VALUE, 0, IARG_END); 
		//print_stacktrace(); 
		
		//TraceFile << "Function: sqrt" << " 	 address: " << RTN_Address(sqrtRtn) << endl; 
		TraceFile << "Function: sqrt" << endl<< "stack: "<< endl << Backtrace(skip=1) << endl; 
		TraceFile << "sqrtRtn ID: " << std::dec << LEVEL_PINCLIENT::RTN_No(sqrtRtn) << endl; 
		TraceFile << "--------------------------------------------------------------------------------" << endl; 
		RTN_Close(sqrtRtn); 
	} 

	RTN sinRtn = RTN_FindByName(img, SIN); 
	if (RTN_Valid(sinRtn)) 
	{ 
		RTN_Open(sinRtn); 
		
		//int PinCCTLibInit(IsInterestingInsFptr isInterestingIns, FILE* logFile, CCTLibInstrumentInsCallback userCallback, VOID* userCallbackArg, BOOL doDataCentric = false); 
		int PinCCTLibInit(IsInterestingInsFptr isInterestingIns, TraceFile , CCTLibInstrumentInsCallback userCallback, VOID* userCallbackArg, false); 
		// Instrument sin() to print the input argument value and the 
		// return value.
		RTN_InsertCall(sinRtn, IPOINT_BEFORE, (AFUNPTR)Arg1Before, IARG_ADDRINT,
		               SIN,IARG_FUNCARG_ENTRYPOINT_VALUE, 0, IARG_END); 
		//print_stacktrace(); 
		
		//TraceFile << "Function: sin" << " 	 address: " << RTN_Address(sinRtn) << endl; 
		TraceFile << "Function: sin" << endl<< "stack: "<< endl << Backtrace(skip=1) << endl; 
		TraceFile << "sinRtn ID: " << std::dec << LEVEL_PINCLIENT::RTN_No(sinRtn) << endl; 
		TraceFile << "--------------------------------------------------------------------------------" << endl; 
		RTN_Close(sinRtn); 
	} 

	RTN cosRtn = RTN_FindByName(img, COS); 
	if (RTN_Valid(cosRtn)) 
	{ 
		RTN_Open(cosRtn); 
		
		//int PinCCTLibInit(IsInterestingInsFptr isInterestingIns, FILE* logFile, CCTLibInstrumentInsCallback userCallback, VOID* userCallbackArg, BOOL doDataCentric = false); 
		int PinCCTLibInit(IsInterestingInsFptr isInterestingIns, TraceFile , CCTLibInstrumentInsCallback userCallback, VOID* userCallbackArg, false); 
		// Instrument cos() to print the input argument value and the 
		// return value.
		RTN_InsertCall(cosRtn, IPOINT_BEFORE, (AFUNPTR)Arg1Before, IARG_ADDRINT,
		               COS,IARG_FUNCARG_ENTRYPOINT_VALUE, 0, IARG_END); 
		//print_stacktrace(); 
		
		//TraceFile << "Function: cos" << " 	 address: " << RTN_Address(cosRtn) << endl; 
		TraceFile << "Function: cos" << endl<< "stack: "<< endl << Backtrace(skip=1) << endl; 
		TraceFile << "cosRtn ID: " << std::dec << LEVEL_PINCLIENT::RTN_No(cosRtn) << endl; 
		TraceFile << "--------------------------------------------------------------------------------" << endl; 
		RTN_Close(cosRtn); 
	} 

	RTN tanRtn = RTN_FindByName(img, TAN); 
	if (RTN_Valid(tanRtn)) 
	{ 
		RTN_Open(tanRtn); 
		
		//int PinCCTLibInit(IsInterestingInsFptr isInterestingIns, FILE* logFile, CCTLibInstrumentInsCallback userCallback, VOID* userCallbackArg, BOOL doDataCentric = false); 
		int PinCCTLibInit(IsInterestingInsFptr isInterestingIns, TraceFile , CCTLibInstrumentInsCallback userCallback, VOID* userCallbackArg, false); 
		// Instrument tan() to print the input argument value and the 
		// return value.
		RTN_InsertCall(tanRtn, IPOINT_BEFORE, (AFUNPTR)Arg1Before, IARG_ADDRINT,
		               TAN,IARG_FUNCARG_ENTRYPOINT_VALUE, 0, IARG_END); 
		//print_stacktrace(); 
		
		//TraceFile << "Function: tan" << " 	 address: " << RTN_Address(tanRtn) << endl; 
		TraceFile << "Function: tan" << endl<< "stack: "<< endl << Backtrace(skip=1) << endl; 
		TraceFile << "tanRtn ID: " << std::dec << LEVEL_PINCLIENT::RTN_No(tanRtn) << endl; 
		TraceFile << "--------------------------------------------------------------------------------" << endl; 
		RTN_Close(tanRtn); 
	} 

	RTN asinRtn = RTN_FindByName(img, ASIN); 
	if (RTN_Valid(asinRtn)) 
	{ 
		RTN_Open(asinRtn); 
		
		//int PinCCTLibInit(IsInterestingInsFptr isInterestingIns, FILE* logFile, CCTLibInstrumentInsCallback userCallback, VOID* userCallbackArg, BOOL doDataCentric = false); 
		int PinCCTLibInit(IsInterestingInsFptr isInterestingIns, TraceFile , CCTLibInstrumentInsCallback userCallback, VOID* userCallbackArg, false); 
		// Instrument asin() to print the input argument value and the 
		// return value.
		RTN_InsertCall(asinRtn, IPOINT_BEFORE, (AFUNPTR)Arg1Before, IARG_ADDRINT,
		               ASIN,IARG_FUNCARG_ENTRYPOINT_VALUE, 0, IARG_END); 
		//print_stacktrace(); 
		
		//TraceFile << "Function: asin" << " 	 address: " << RTN_Address(asinRtn) << endl; 
		TraceFile << "Function: asin" << endl<< "stack: "<< endl << Backtrace(skip=1) << endl; 
		TraceFile << "asinRtn ID: " << std::dec << LEVEL_PINCLIENT::RTN_No(asinRtn) << endl; 
		TraceFile << "--------------------------------------------------------------------------------" << endl; 
		RTN_Close(asinRtn); 
	} 

	RTN acosRtn = RTN_FindByName(img, ACOS); 
	if (RTN_Valid(acosRtn)) 
	{ 
		RTN_Open(acosRtn); 
		
		//int PinCCTLibInit(IsInterestingInsFptr isInterestingIns, FILE* logFile, CCTLibInstrumentInsCallback userCallback, VOID* userCallbackArg, BOOL doDataCentric = false); 
		int PinCCTLibInit(IsInterestingInsFptr isInterestingIns, TraceFile , CCTLibInstrumentInsCallback userCallback, VOID* userCallbackArg, false); 
		// Instrument acos() to print the input argument value and the 
		// return value.
		RTN_InsertCall(acosRtn, IPOINT_BEFORE, (AFUNPTR)Arg1Before, IARG_ADDRINT,
		               ACOS,IARG_FUNCARG_ENTRYPOINT_VALUE, 0, IARG_END); 
		//print_stacktrace(); 
		
		//TraceFile << "Function: acos" << " 	 address: " << RTN_Address(acosRtn) << endl; 
		TraceFile << "Function: acos" << endl<< "stack: "<< endl << Backtrace(skip=1) << endl; 
		TraceFile << "acosRtn ID: " << std::dec << LEVEL_PINCLIENT::RTN_No(acosRtn) << endl; 
		TraceFile << "--------------------------------------------------------------------------------" << endl; 
		RTN_Close(acosRtn); 
	} 

	RTN atanRtn = RTN_FindByName(img, ATAN); 
	if (RTN_Valid(atanRtn)) 
	{ 
		RTN_Open(atanRtn); 
		
		//int PinCCTLibInit(IsInterestingInsFptr isInterestingIns, FILE* logFile, CCTLibInstrumentInsCallback userCallback, VOID* userCallbackArg, BOOL doDataCentric = false); 
		int PinCCTLibInit(IsInterestingInsFptr isInterestingIns, TraceFile , CCTLibInstrumentInsCallback userCallback, VOID* userCallbackArg, false); 
		// Instrument atan() to print the input argument value and the 
		// return value.
		RTN_InsertCall(atanRtn, IPOINT_BEFORE, (AFUNPTR)Arg1Before, IARG_ADDRINT,
		               ATAN,IARG_FUNCARG_ENTRYPOINT_VALUE, 0, IARG_END); 
		//print_stacktrace(); 
		
		//TraceFile << "Function: atan" << " 	 address: " << RTN_Address(atanRtn) << endl; 
		TraceFile << "Function: atan" << endl<< "stack: "<< endl << Backtrace(skip=1) << endl; 
		TraceFile << "atanRtn ID: " << std::dec << LEVEL_PINCLIENT::RTN_No(atanRtn) << endl; 
		TraceFile << "--------------------------------------------------------------------------------" << endl; 
		RTN_Close(atanRtn); 
	} 

}


/* ========================================================================= */
/* Fini Function			                                     */
/* ========================================================================= */

VOID Fini(INT32 code, VOID *v)
{
	TraceFile.close();
	//treeExpPntr->Print();
	
	fPntr->WriteObject(&stackVector, "stackVector");
	fPntr->Write();
	fPntr->Close();
}


/* ========================================================================= */
/* Print Help Message                                                        */
/* ========================================================================= */

INT32 Usage()
{
    cerr << "This tool produces a trace of calls to mathematical functions." 
	 << endl;
    cerr << endl << KNOB_BASE::StringKnobSummary() << endl;
    return -1;
}


/* ========================================================================= */ 
/* Backtrace Function                                                        */ 
/* ========================================================================= */ 

std::string Backtrace(int skip = 1) 
{ 
	void *callstack[128]; 
	const int nMaxFrames = sizeof(callstack) / sizeof(callstack[0]); 
	char buf[1024]; 
	int nFrames = backtrace(callstack, nMaxFrames); 
	char **symbols = backtrace_symbols(callstack, nFrames); 
 
	std::ostringstream trace_buf; 
	for (int i = skip; i < nFrames; i++)  
	{ 
		Dl_info info; 
		if (dladdr(callstack[i], &info) && info.dli_sname)  
		{ 
			char *demangled = NULL; 
			int status = -1; 
			if (info.dli_sname[0] == '_') 
				demangled = abi::__cxa_demangle(info.dli_sname, 
				NULL, 0, &status); 
			snprintf(buf, sizeof(buf), "%-3d %*p %s + %zd\n", 
				i, int(2 + sizeof(void*) * 2), 
				callstack[i], 
				status == 0 ? demangled : 
				info.dli_sname == 0 ? 
				symbols[i] : info.dli_sname, 
				(char *)callstack[i] - (char 
				*)info.dli_saddr); 
			free(demangled); 
		}  
		else  
		{ 
			snprintf(buf, sizeof(buf), "%-3d %*p %s\n", 
				i, int(2 + sizeof(void*) * 2), 
				callstack[i], symbols[i]); 
		} 
                trace_buf << buf; 
        } 
	free(symbols); 
	if (nFrames == nMaxFrames) 
		trace_buf << "[truncated]\n"; 
	return trace_buf.str(); 
}
